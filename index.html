<!DOCTYPE html>
<html>

<head>
	<title>Webcam Image Processor</title>
	<style>
		body,
		html {
			margin: 0;
			padding: 0;
			height: 100%;
			display: flex;
			flex-direction: row;
			overflow: hidden;
			/* Prevents scrollbars */
		}

		
		#overlay {
		position: absolute;
		top: 0;
		left: 0;
		width: 50%;
		height: 100%;
		background-color: white;
		display: none;
		}


		#leftPanel {
			width: 35%;
			height: 100vh;
			max-height: 100vh;
			/* Adjust webcam and sent image width here */
			display: flex;
			flex-direction: column;
			justify-content: space-between;
			/* Align to top */
			padding: 10px;
			box-sizing: border-box;
		}

		#smallDuo {
	        position: relative;
			width: 100%;
			/* Adjust webcam and sent image width here */
			display: flex;
			flex-direction: row;
			justify-content: flex-start;
			/* Align to top */
			/* padding: 10px; */
			/* box-sizing: border-box; */
		}

		#rightPanel {
			width: 65%;
			/* Adjust processed image width here */
			height: 100vh;
			/* Full viewport height */
			display: flex;
			justify-content: right;
			/* align-items: flex-start; */
			/* Align to top */
			padding: 10px;
			/* box-sizing: border-box; */
			overflow: hidden;
			/* Prevents scrollbars */
		}

		#webcam,
		#lastCaptured {
			width: 50%;
			/* Adjust to set the actual size of webcam and sent image */
			margin-bottom: 10px;
			/* box-sizing: border-box; */
			/* aspect-ratio: 640/480; */
			/* max-width: 100%;  */
			/* max-height: 22vh; */
		}

		#previousCaptured {
			width: 100%;
			/* height: 100%; */
			/* Adjust to set the actual size of webcam and sent image */
			margin-bottom: 10px;
			/* box-sizing: border-box; */
			/* aspect-ratio: 640/480; */
			/* max-width: 100%;  */
			/* max-height: 22vh; */
		}

		#result {
			max-width: 200%;
			width: auto;
			/* max-height:100%; */
			max-height: 100vh;
			/* Maintain aspect ratio */
			/* max-width: 200%; */
			/* Limit width to the container */
			/* Limit height to the viewport */
			/* box-sizing: border-box; */
		}

		#canvas {
			display: none;
		}
	</style>
</head>

<body style="background-color:black;">
	<div id="leftPanel">
		<div id="smallDuo">
			<div id="overlay"></div> <!-- Overlay for blinking effect -->
			<video id="webcam" autoplay></video>
			<img id="lastCaptured" style="display: none;">
		</div>
		<img id="previousCaptured" style="display: none;">
		<img style="display: block;" src="https://github.com/ezalos/swag_mirror/blob/main/lusel_velidoe.png?raw=true">
	</div>
	<div id="rightPanel">
		<img id="result" style="max-height: 100vh; display: none;">
	</div>
	<canvas id="canvas" style="display: none;"></canvas>

	<script>
		const video = document.getElementById('webcam');
		const canvas = document.getElementById('canvas');
		const resultImage = document.getElementById('result');
		const lastCapturedImage = document.getElementById('lastCaptured');
		const previousCapturedImage = document.getElementById('previousCaptured');
		const overlay = document.getElementById('overlay');

		let lastImageDataUrl = '';

		const serverIP = '78.202.206.149';
		const serverPort = '1111';
		const serverEndpoint = `http://${serverIP}:${serverPort}/process`;

		navigator.mediaDevices.getUserMedia({ video: true })
			.then(stream => {
				video.srcObject = stream;
				captureAndSendImage(); // Start the cycle
			})
			.catch(err => {
				console.error("Error accessing webcam", err);
			});

		function captureAndSendImage() {
			blink(() => {
				const context = canvas.getContext('2d');
				canvas.width = video.videoWidth;
				canvas.height = video.videoHeight;
				context.drawImage(video, 0, 0);
				const imageData = canvas.toDataURL('image/png');
				if (lastImageDataUrl) {
					previousCapturedImage.src = lastImageDataUrl;
					previousCapturedImage.style.display = 'block';
				}

				lastImageDataUrl = imageData;
				lastCapturedImage.src = imageData;
				lastCapturedImage.style.display = 'block';

				fetch(serverEndpoint, {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({ image: imageData })
				})
					.then(response => {
						if (!response.ok) {
							throw new Error(`HTTP error! status: ${response.status}`);
						}
						return response.json();
					})
					.then(data => {
						resultImage.src = data.image;
						resultImage.style.display = 'block';
						captureAndSendImage(); // Repeat the cycle
					})
					.catch(err => {
						console.error('Error processing image:', err);
						setTimeout(captureAndSendImage, 1000); // Retry after a delay if an error occurs
					});
			});
		}

		    function blink(callback) {
					let blinkCount = 0;
					overlay.style.display = 'block'; // Show the overlay
					const blinkInterval = setInterval(() => {
						overlay.style.opacity = blinkCount % 5 === 0 ? '1' : '0';
						blinkCount++;
						if (blinkCount === 15) {
							clearInterval(blinkInterval);
							overlay.style.display = 'none'; // Ensure it's hidden after blinking
							callback(); // Proceed to capture and send the image
						}
					}, 75); // Blink every 333ms, 3 times
				}
	</script>
</body>

</html>