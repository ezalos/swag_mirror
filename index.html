<!DOCTYPE html>
<html>

<head>
	<title>Webcam Image Processor</title>
	<style>
		body,
		html {
			margin: 0;
			padding: 0;
			height: 100%;
			display: flex;
			flex-direction: row;
			overflow: hidden;
			/* Prevents scrollbars */
		}

		#leftPanel {
			flex: 0 0 35%;
			/* The left panel will take up 35% of the width and not grow or shrink */
			display: flex;
			justify-content: center;
			flex-direction: column;
			padding: 10px;
			box-sizing: border-box;
			max-height: 95vh;
		}

		#smallDuo {
			position: relative;
			display: flex;
			flex-direction: row;
			/* Stack the webcam and the last captured image vertically */
			align-items: center;
			/* Center align the items */
			height: 30%;
			/* Half of the left panel's height */
		}

		#rightPanel {
			flex-grow: 1;
			/* Allow the right panel to grow and fill the remaining space */
			display: flex;
			justify-content: center;
			/* align-items: center; */
			padding: 10px;
			overflow: hidden;
		}

		#webcam,
		#lastCaptured{
			width: 50%;
			/* Take the full width of their container */
			object-fit: contain;
			/* Maintain aspect ratio without cropping */
		}

		#previousCaptured {
			height: 50%;
			/* Take the full width of their container */
			object-fit: contain;
			/* Maintain aspect ratio without cropping */
		}

		#logo {
			height: 15%;
			/* Take the full width of their container */
			object-fit: contain;
			/* Maintain aspect ratio without cropping */
		}

		#result {
			max-width: 100%;
			max-height: 95vh;
			/* Adjust the height to be a bit less than the full viewport height */
			object-fit: contain;
			/* Maintain aspect ratio without cropping */
		}

		#overlay {
			position: absolute;
			width: 50%;
			height: 100%;
			background-color: white;
			display: none;
		}

		#canvas {
			display: none;
		}
	</style>
</head>

<body style="background-color:black;">
	<div id="leftPanel">
		<div id="smallDuo">
			<div id="overlay"></div> <!-- Overlay for blinking effect -->
			<video id="webcam" autoplay></video>
			<img id="lastCaptured" style="display: none;">
		</div>
		<img id="previousCaptured" style="display: none;">
		<img id="logo" src="https://github.com/ezalos/swag_mirror/blob/main/lusel_velidoe.png?raw=true">
	</div>
	<div id="rightPanel">
		<img id="result" style="max-height: 100vh; display: none;">
	</div>
	<canvas id="canvas" style="display: none;"></canvas>

	<script>
		const video = document.getElementById('webcam');
		const canvas = document.getElementById('canvas');
		const resultImage = document.getElementById('result');
		const lastCapturedImage = document.getElementById('lastCaptured');
		const previousCapturedImage = document.getElementById('previousCaptured');
		const overlay = document.getElementById('overlay');

		let lastImageDataUrl = '';

		const serverIP = '78.202.206.149';
		const serverPort = '1111';
		const serverEndpoint = `http://${serverIP}:${serverPort}/process`;

		navigator.mediaDevices.getUserMedia({ video: true })
			.then(stream => {
				video.srcObject = stream;
				captureAndSendImage(); // Start the cycle
			})
			.catch(err => {
				console.error("Error accessing webcam", err);
			});

		function captureAndSendImage() {
			blink(() => {
				const context = canvas.getContext('2d');
				canvas.width = video.videoWidth;
				canvas.height = video.videoHeight;
				context.drawImage(video, 0, 0);
				const imageData = canvas.toDataURL('image/png');
				if (lastImageDataUrl) {
					previousCapturedImage.src = lastImageDataUrl;
					previousCapturedImage.style.display = 'block';
				}

				lastImageDataUrl = imageData;
				lastCapturedImage.src = imageData;
				lastCapturedImage.style.display = 'block';

				fetch(serverEndpoint, {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({ image: imageData })
				})
					.then(response => {
						if (!response.ok) {
							throw new Error(`HTTP error! status: ${response.status}`);
						}
						return response.json();
					})
					.then(data => {
						resultImage.src = data.image;
						resultImage.style.display = 'block';
						captureAndSendImage(); // Repeat the cycle
					})
					.catch(err => {
						console.error('Error processing image:', err);
						setTimeout(captureAndSendImage, 1000); // Retry after a delay if an error occurs
					});
			});
		}

		function blink(callback) {
			let blinkCount = 0;
			overlay.style.display = 'block'; // Show the overlay
			const blinkInterval = setInterval(() => {
				overlay.style.opacity = blinkCount % 5 === 0 ? '1' : '0';
				blinkCount++;
				if (blinkCount === 15) {
					clearInterval(blinkInterval);
					overlay.style.display = 'none'; // Ensure it's hidden after blinking
					callback(); // Proceed to capture and send the image
				}
			}, 75);
		}
	</script>
</body>

</html>